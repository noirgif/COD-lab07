module control(
    input clk,
    input rst_n,
	input [5:0] op,
	input [5:0] funct,
	output ALUSrcA,
    output reg [1:0] ALUSrcB,//[1:0]
    output reg [3:0] ALUOp,//[3:0]
    output Branch,
    output IorD,
    output IRWrite,
    output MemtoReg,
    output MemWrite,
    output reg [1:0] PCSrc, //[1:0]
    output PCWrite,
    output RegDst,
    output RegWrite

);

parameter ADD = 6'b0;
parameter ADDI = 6'b1000;
parameter BGTZ = 6'b111;
parameter J = 6'b10;
parameter LW = 6'b100011;
parameter SW = 6'b101011;
parameter ORI = 6'b001101;

parameter FETCH = 4'h0;
parameter DECODE = 4'h1;
parameter MEMADDR = 4'h2;
parameter MEMREAD = 4'h3;
parameter MEMWB = 4'h4;
parameter MEMWR = 4'h5;
parameter EX = 4'h6; 
parameter WB = 4'h7;
parameter BR = 4'h8;
parameter EX_I = 4'h9;
parameter JUMP = 4'hb;

reg [3:0] state;
reg [3:0] next_state;
reg [1:0] scnt;//substate_counter
reg [1:0] count;

parameter RTYPE = 2'h0;
parameter ITYPE = 2'h1;
parameter JTYPE = 2'h2;
reg [1:0] optype;

always @*
begin
    case(op)
        ADD: optype = RTYPE;
        J: optype = JTYPE;
        default: optype = ITYPE;
    endcase
end

always @(posedge clk, negedge rst_n)
begin
    if(~rst_n)
    begin
        state <= 0;
        scnt <= 0;
    end
    else
    begin
        if(scnt == count)
        begin
            state <= next_state;
            scnt <= 0;
        end
        else
            scnt <= scnt + 1;
    end
end

always @*
begin
    case(state)
        FETCH:
            count = 1;
        MEMREAD:
            count = 1;
        default:
            count = 0;
    endcase
end

always @*
begin
    case(state)
        FETCH:   
            begin
                next_state = DECODE;
            end
        DECODE:
            begin
                case(op)
                    ADD:
                        next_state = EX;
                    ADDI:
                        next_state = EX;
                    BGTZ:
                        next_state = BR;
                    LW:
                        next_state = MEMADDR;
                    SW:
                        next_state = MEMADDR;
                    ORI:
                        next_state = EX;
                    J:
                        next_state = JUMP;
                    default:
                        next_state = 4'hz;
                endcase
            end
        MEMADDR:
            begin
                case(op)
                    LW:
                        next_state = MEMREAD;
                    SW:
                        next_state = MEMWR;
                    default:
                        next_state = 4'hz;
                endcase
            end
        MEMREAD:
            next_state = MEMWB;
        EX:
            next_state = WB;
        default:
            next_state = FETCH;
    endcase
end

assign IRWrite = state == FETCH;
assign IorD = (state == MEMREAD) | (state == MEMWR);
assign RegDst = (state == WB) & (optype == RTYPE);
assign RegWrite = (state == MEMWB) | (state == WB);
assign ALUSrcA = (state == MEMADDR) | (state == EX) | (state == BR);
assign Branch = state == BR;
assign MemWrite = state == MEMWR;
assign PCWrite = (state == FETCH && scnt == 0) | (state == JUMP);
assign MemtoReg = state == MEMWB;

always @*
begin
    case(state)
        FETCH: ALUSrcB = 2'b01;
        DECODE: ALUSrcB = 2'b11;
        MEMADDR: ALUSrcB = 2'b10;
        EX: ALUSrcB = (optype == RTYPE) ? 2'b00 : 2'b10;
        BR: ALUSrcB = 2'b00;
        MEMADDR: ALUSrcB = 2'b00;
    endcase
end

always @*
begin
    case(state)
        FETCH: PCSrc = 2'b00;
        BR: PCSrc = 2'b01;
        JUMP: PCSrc = 2'b10;
        default: PCSrc = 4'hz;
    endcase
end

always @*
begin
    case(state)
    EX:
    begin
        case(op)
            ADD:
                begin
                    case(funct)
                        6'h20: ALUOp = 2;
                        default: ALUOp = 4'hz;
                    endcase
                end
            ADDI: ALUOp = 2;
            ORI: ALUOp = 1;
            default: ALUOp = 4'hz;
        endcase
    end
    BR:
    begin
        case(op)
            BGTZ:
                ALUOp = 8;
        endcase
    end
    default:
        ALUOp = 2;
    endcase
end 

endmodule

